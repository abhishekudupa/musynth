symmetrictypes {
    CacheIDType : { C1, C2 };
    DataType : { D0, D1 };
}

Automaton Environment[c] foreach c in CacheIDType
{
    states : { InitState[d] foreach d in DataType, 
               IssuedGet, IssuedPut, 
               IssuedHavoc[d] foreach d in DataType };
    
    inputs {
        GetDone[d] foreach d in DataType,
        HavocDone[d] foreach d in DataType,
        PutDone
    };

    outputs {
        Get, Put,
        Havoc[d] foreach d in DataType
    };

    transitions {
        (InitState[d], Get, IssuedGet foreach d in DataType),
        (InitState[d], Put, IssuedPut foreach d in DataType),
        (InitState[d1], Havoc[d2], IssuedHavoc[d2] foreach d1, d2 in DataType),

        (IssuedGet, GetDone[d], InitState[d] foreach d in DataType),
        (IssuedPut, PutDone, InitState[d] foreach d in DataType),
        (IssuedHavoc[d], HavocDone[d], InitState[d] foreach d in DataType)
    };
}

Automaton Oracle
{
    states : { Data[d] foreach d in DataType };

    inputs {
        HavocDone[d] foreach d in DataType
    };

    transitions {
        (Data[d1], HavocDone[d2], Data[d2] foreach d1, d2 in DataType)
    };
}

ChannelAutomaton ReqChannel[c] foreach c in CacheIDType
{
    unordered, lossless, nonduplicating;
    capacity = 1;    

    messages {
        Req2Dir, 
        WB2Dir[d] foreach d in DataType,
        InvAck2Dir[d] foreach d in DataType,
        Ack2Dir
    };
}

ChannelAutomaton RspChannel[c] foreach c in CacheIDType
{
    unordered, lossless, nonduplicating;
    capacity = 1;

    messages {
        Rsp[d] foreach d in DataType,
        WBAck,
        Inv
    };
}

PartialAutomaton Cache[c] foreach c in CacheIDType
{
    states : { CI : incomplete, 
               CIV1 : complete,
               CIV2 : complete,
               CIV3[d] foreach d in DataType : complete,
               CIV4[d] foreach d in DataType : complete,
               CIVH1[d] foreach d in DataType : complete,
               CIVH2[d] foreach d in DataType : complete,
               CIVH3[d] foreach d in DataType : complete,
               CIVH4[d] foreach d in DataType : complete,
               CV[d] foreach d in DataType : complete, 
               CVP[d] foreach d in DataType : complete,
               CVH[d] foreach d in DataType : complete,
               CVI1[d] foreach d in DataType : complete,
               CVI2 : incomplete, 
               CVI3 : complete,
               CVI4[d] foreach d in DataType : complete };

    inputs {
        Get, Put, 
        Havoc[d] foreach d in DataType,
        Rsp'[d] foreach d in DataType,
        WBAck', Inv'
    };

    outputs {
        Req2Dir, 
        WB2Dir[d] foreach d in DataType, 
        InvAck2Dir[d] foreach d in DataType,
        Ack2Dir,
        GetDone[d] foreach d in DataType,
        PutDone,
        HavocDone[d] foreach d in DataType
    };

    transitions {
        (CI, Get, CIV1),
        (CIV1, Req2Dir, CIV2),
        (CIV2, Rsp'[d], CIV3[d] foreach d in DataType),
        (CIV3[d], Ack2Dir, CIV4[d] foreach d in DataType),
        (CIV4[d], GetDone[d], CV[d] foreach d in DataType),

        (CI, Havoc[d], CIVH1[d] foreach d in DataType),
        (CIVH1[d], Req2Dir, CIVH2[d] foreach d in DataType),
        (CIVH2[d1], Rsp'[d2], CIVH3[d1] foreach d1, d2 in DataType),
        (CIVH3[d], Ack2Dir, CIVH4[d] foreach d in DataType),
        (CIVH4[d], HavocDone[d], CV[d] foreach d in DataType),

        (CV[d], Get, CVP[d] foreach d in DataType),
        (CVP[d], GetDone[d], CV[d] foreach d in DataType),
        (CV[d1], Havoc[d2], CVH[d2] foreach d1, d2 in DataType),
        (CVH[d], HavocDone[d], CV[d] foreach d in DataType),

        (CV[d], Put, CVI1[d] foreach d in DataType),
        (CVI1[d], WB2Dir[d], CVI2 foreach d in DataType),
        (CVI2, WBAck', CVI3),
        (CVI3, PutDone, CI),

        (CV[d], Inv', CVI4[d] foreach d in DataType),
        (CVI4[d], InvAck2Dir[d], CI foreach d in DataType)
        
        /*
        (CVI2, Inv', CI)
        */
    };
}

PartialAutomaton Directory
{
    states : { DI[d] foreach d in DataType : complete,
               DIV1[c][d] foreach c in CacheIDType foreach d in DataType : complete,
               DIV2[c] foreach c in CacheIDType : complete,
               DV[c] foreach c in CacheIDType : complete,
               DVV1[c1][c2] foreach c1, c2 in CacheIDType (!= c1 c2) : complete,
               DVV2[c1][c2] foreach c1, c2 in CacheIDType (!= c1 c2) : incomplete,
               DVV3[c][d] foreach c in CacheIDType foreach d in DataType : complete,
               DVV4[c] foreach c in CacheIDType : complete,
               DVI1[c][d] foreach c in CacheIDType foreach d in DataType : complete };

    inputs {
        Req2Dir'[c] foreach c in CacheIDType,
        WB2Dir'[c][d] foreach c in CacheIDType foreach d in DataType,
        InvAck2Dir'[c][d] foreach c in CacheIDType foreach d in DataType,
        Ack2Dir'[c] foreach c in CacheIDType
    };

    outputs {
        Rsp[c][d] foreach c in CacheIDType foreach d in DataType,
        WBAck[c] foreach c in CacheIDType,
        Inv[c] foreach c in CacheIDType
    };

    transitions {
        (DI[d], Req2Dir'[c], DIV1[c][d] foreach d in DataType foreach c in CacheIDType),
        (DIV1[c][d], Rsp[c][d], DIV2[c] foreach d in DataType foreach c in CacheIDType),
        (DIV2[c], Ack2Dir'[c], DV[c] foreach c in CacheIDType),
        
        (DV[c1], Req2Dir'[c2], DVV1[c1][c2] foreach c1, c2 in CacheIDType (!= c1 c2)),
        (DVV1[c1][c2], Inv[c1], DVV2[c1][c2] foreach c1, c2 in CacheIDType (!= c1 c2)),
        (DVV2[c1][c2], InvAck2Dir'[c1][d], DVV3[c2][d] 
         foreach c1, c2 in CacheIDType 
         foreach d in DataType (!= c1 c2)),
        (DVV3[c][d], Rsp[c][d], DVV4[c] foreach c in CacheIDType foreach d in DataType),
        (DVV4[c], Ack2Dir'[c], DV[c] foreach c in CacheIDType),

        (DV[c], WB2Dir'[c][d], DVI1[c][d] foreach c in CacheIDType foreach d in DataType),
        (DVI1[c][d], WBAck[c], DI[d] foreach c in CacheIDType foreach d in DataType)
        
        /*
        (DVV2[c1][c2], WB2Dir'[c1][d], DVV3[c2][d] foreach c1, c2 in CacheIDType foreach d in DataType (c1 != c2))
        */
    };
}

init {
    Environment[c].state = InitState[d] foreach c in CacheIDType foreach d in DataType;
    Oracle.state = Data[d], Directory.state = Directory.DI[d] foreach d in DataType;
    Cache[c].state = CI foreach c in CacheIDType;
}

invariant "Coherence Invariant" {
    (forall d in DataType 
     (forall c in CacheIDType
      (-> (= Cache[c].state CV[d]) (= Oracle.state Data[d]))))
}

invariant "One Valid Invariant" {
    (forall c1 in CacheIDType
     (forall c2 in CacheIDType
      (forall d1 in DataType
       (forall d2 in DataType
        (-> (!= c1 c2) (-> (= Cache[c1].state CV[d1]) 
                           (!= Cache[c2].state CV[d2])))))))
}

ctlspec "I-V liveness on Get" {
    (forall c in CacheIDType
     (exists d in DataType
      (AG (-> (= Environment[c].state IssuedGet) (EF (and (= Environment[c].state InitState[d]) (= Oracle.state Data[d])))))))
}

ctlspec "I-V liveness on Havoc" {
    (forall c in CacheIDType
     (forall d in DataType
      (AG (-> (= Environment[c].state IssuedHavoc[d]) (EF (and (= Environment[c].state InitState[d]) (= Oracle.state Data[d])))))))
}

ctlspec "V-I liveness" {
    (forall c in CacheIDType
     (exists d in DataType
      (AG (-> (= Environment[c].state IssuedPut) (EF (= Environment[c].state InitState[d]))))))
}
